id: "akao:artifact:architectural-reformation:phase-3:step-1:symbol-system:v1"
metadata:
  specification: "Comprehensive symbol system for Pure Logic .a language with dual input modes"
  scope: "Mathematical logic symbols with ASCII fallbacks, input methods, and transformation algorithms"
  timeline: "2025-08-05"
  rationale: "Enable mathematical notation while maintaining universal keyboard accessibility"
  methodology: "Bidirectional symbol transformation with intelligent input completion and rendering"
  references:
    - "akao:artifact:architectural-reformation:phase-3:step-1:language-requirements:v1"
    - "Unicode Mathematical Operators standard"

# Core Symbol Categories
symbol_categories:
  logical_operators:
    conjunction:
      unicode_symbol: "∧"
      ascii_equivalent: "and"
      keyboard_input: ["and", "/\\", "&"]
      description: "Logical conjunction (AND)"
      precedence: 3
      associativity: "left"
      example: "P ∧ Q | P and Q"
    
    disjunction:
      unicode_symbol: "∨"
      ascii_equivalent: "or"
      keyboard_input: ["or", "\\/", "|"]
      description: "Logical disjunction (OR)"
      precedence: 2
      associativity: "left"
      example: "P ∨ Q | P or Q"
    
    negation:
      unicode_symbol: "¬"
      ascii_equivalent: "not"
      keyboard_input: ["not", "~", "!"]
      description: "Logical negation (NOT)"
      precedence: 4
      associativity: "right"
      example: "¬P | not P"
    
    implication:
      unicode_symbol: "→"
      ascii_equivalent: "implies"
      keyboard_input: ["implies", "->", "=>"]
      description: "Logical implication"
      precedence: 1
      associativity: "right"
      example: "P → Q | P implies Q"
    
    biconditional:
      unicode_symbol: "↔"
      ascii_equivalent: "iff"
      keyboard_input: ["iff", "<->", "<=>"]
      description: "Logical biconditional (if and only if)"
      precedence: 0
      associativity: "left"
      example: "P ↔ Q | P iff Q"
    
    exclusive_or:
      unicode_symbol: "⊕"
      ascii_equivalent: "xor"
      keyboard_input: ["xor", "(+)"]
      description: "Exclusive or"
      precedence: 2
      associativity: "left"
      example: "P ⊕ Q | P xor Q"
  
  quantifiers:
    universal_quantifier:
      unicode_symbol: "∀"
      ascii_equivalent: "forall"
      keyboard_input: ["forall", "all", "\\forall"]
      description: "Universal quantifier"
      syntax: "∀x: P(x) | forall x: P(x)"
      binding_power: 5
    
    existential_quantifier:
      unicode_symbol: "∃"
      ascii_equivalent: "exists"
      keyboard_input: ["exists", "some", "\\exists"]
      description: "Existential quantifier"
      syntax: "∃x: P(x) | exists x: P(x)"
      binding_power: 5
    
    unique_existence:
      unicode_symbol: "∃!"
      ascii_equivalent: "exists_unique"
      keyboard_input: ["exists!", "unique", "\\exists!"]
      description: "Unique existence quantifier"
      syntax: "∃!x: P(x) | exists_unique x: P(x)"
      binding_power: 5
  
  set_operations:
    element_of:
      unicode_symbol: "∈"
      ascii_equivalent: "in"
      keyboard_input: ["in", "elem", "\\in"]
      description: "Set membership"
      example: "x ∈ S | x in S"
    
    not_element_of:
      unicode_symbol: "∉"
      ascii_equivalent: "not_in"
      keyboard_input: ["not_in", "notin", "\\notin"]
      description: "Not a member of set"
      example: "x ∉ S | x not_in S"
    
    subset:
      unicode_symbol: "⊆"
      ascii_equivalent: "subset"
      keyboard_input: ["subset", "<=", "\\subseteq"]
      description: "Subset or equal"
      example: "A ⊆ B | A subset B"
    
    proper_subset:
      unicode_symbol: "⊂"
      ascii_equivalent: "proper_subset"
      keyboard_input: ["proper_subset", "<", "\\subset"]
      description: "Proper subset"
      example: "A ⊂ B | A proper_subset B"
    
    union:
      unicode_symbol: "∪"
      ascii_equivalent: "union"
      keyboard_input: ["union", "\\cup"]
      description: "Set union"
      example: "A ∪ B | A union B"
    
    intersection:
      unicode_symbol: "∩"
      ascii_equivalent: "intersection"
      keyboard_input: ["intersection", "\\cap"]
      description: "Set intersection"
      example: "A ∩ B | A intersection B"
    
    difference:
      unicode_symbol: "∖" 
      ascii_equivalent: "difference"
      keyboard_input: ["difference", "\\", "\\setminus"]
      description: "Set difference"
      example: "A ∖ B | A difference B"
  
  comparison_operators:
    less_than_or_equal:
      unicode_symbol: "≤"
      ascii_equivalent: "<="
      keyboard_input: ["<=", "\\leq"]
      description: "Less than or equal"
      example: "x ≤ y | x <= y"
    
    greater_than_or_equal:
      unicode_symbol: "≥"
      ascii_equivalent: ">="
      keyboard_input: [">=", "\\geq"]
      description: "Greater than or equal"
      example: "x ≥ y | x >= y"
    
    not_equal:
      unicode_symbol: "≠"
      ascii_equivalent: "!="
      keyboard_input: ["!=", "<>", "\\neq"]
      description: "Not equal"
      example: "x ≠ y | x != y"
    
    approximately_equal:
      unicode_symbol: "≈"
      ascii_equivalent: "~="
      keyboard_input: ["~=", "\\approx"]
      description: "Approximately equal"
      example: "x ≈ y | x ~= y"
  
  mathematical_constants:
    infinity:
      unicode_symbol: "∞"
      ascii_equivalent: "infinity"
      keyboard_input: ["infinity", "inf", "\\infty"]
      description: "Infinity"
      example: "lim_{x→∞} f(x) | lim_{x->infinity} f(x)"
    
    empty_set:
      unicode_symbol: "∅"
      ascii_equivalent: "empty_set"
      keyboard_input: ["empty_set", "\\emptyset"]
      description: "Empty set"
      example: "A ∩ B = ∅ | A intersection B = empty_set"
    
    aleph_null:
      unicode_symbol: "ℵ₀"
      ascii_equivalent: "aleph_0"
      keyboard_input: ["aleph_0", "\\aleph_0"]
      description: "Aleph null (countable infinity)"
      example: "|ℕ| = ℵ₀ | |N| = aleph_0"

# Truth Values
truth_values:
  true_value:
    unicode_symbol: "⊤"
    ascii_equivalent: "true"
    keyboard_input: ["true", "T", "\\top"]
    description: "Logical true"
    
  false_value:
    unicode_symbol: "⊥"
    ascii_equivalent: "false"
    keyboard_input: ["false", "F", "\\bot"]
    description: "Logical false"
    
  unknown_value:
    unicode_symbol: "?"
    ascii_equivalent: "unknown"
    keyboard_input: ["unknown", "?"]
    description: "Unknown truth value"

# Input Processing System
input_processing:
  intelligent_completion:
    trigger_patterns:
      - "Type 'forall' → automatically suggest ∀"
      - "Type 'exists' → automatically suggest ∃"
      - "Type 'and' → automatically suggest ∧"
      - "Type 'or' → automatically suggest ∨"
      - "Type 'not' → automatically suggest ¬"
    
    completion_behavior:
      auto_replace: "Configurable automatic replacement on space/tab"
      suggestion_popup: "Show Unicode symbol in completion popup"
      preview_mode: "Live preview while typing"
    
    context_awareness:
      logical_context: "Prefer logical symbols in logical expressions"
      mathematical_context: "Prefer mathematical symbols in equations"
      string_context: "No symbol replacement inside strings"
  
  symbol_transformation_engine:
    ascii_to_unicode:
      algorithm: "Pattern matching with longest-match priority"
      context_sensitivity: "Consider surrounding syntax for disambiguation"
      reversibility: "Maintain bidirectional transformation capability"
    
    unicode_to_ascii:
      preservation: "Always preserve original Unicode in metadata"
      readability: "Choose most readable ASCII equivalent"
      compatibility: "Ensure ASCII version compiles correctly"
    
    mixed_mode_support:
      flexibility: "Allow mixing Unicode and ASCII in same file"
      normalization: "Normalize to preferred mode on save (configurable)"
      consistency_checking: "Warn about inconsistent symbol usage"

# Rendering and Display
rendering_system:
  font_requirements:
    mathematical_symbols: "Font must support Unicode mathematical operators"
    fallback_fonts: "Graceful fallback for missing symbols"
    recommended_fonts: ["JetBrains Mono", "Fira Code", "Cascadia Code", "Source Code Pro"]
  
  editor_integration:
    syntax_highlighting:
      symbol_highlighting: "Distinct colors for logical vs mathematical symbols"
      operator_precedence: "Visual cues for operator precedence"
      binding_indication: "Visual indication of quantifier binding scope"
    
    symbol_input_methods:
      autocomplete: "Intelligent autocomplete for symbol names"
      symbol_palette: "Graphical symbol picker in IDE"
      keyboard_shortcuts: "Configurable keyboard shortcuts for symbols"
      copy_paste: "Preserve symbols when copying between editors"

# Symbol Transformation Algorithms
transformation_algorithms:
  lexical_analysis:
    symbol_recognition:
      pattern_matching: "Regular expressions for ASCII patterns"
      unicode_detection: "Unicode category-based symbol detection"
      ambiguity_resolution: "Context-based disambiguation rules"
    
    tokenization:
      symbol_tokens: "Separate token types for each symbol category"
      precedence_encoding: "Embed precedence information in tokens"
      position_tracking: "Track source position for error reporting"
  
  semantic_analysis:
    operator_precedence:
      precedence_table: "Complete precedence table for all operators"
      associativity_rules: "Left/right associativity specifications"
      parenthetical_grouping: "Override precedence with parentheses"
    
    type_checking:
      symbol_typing: "Type checking for symbol arguments"
      quantifier_scoping: "Scope checking for quantified variables"
      predicate_arity: "Arity checking for predicate applications"
  
  code_generation:
    backend_abstraction: "Abstract symbol representation for multiple backends"
    optimization: "Optimize symbol operations for target platform"
    debugging_support: "Preserve symbol information for debugging"

# Compatibility and Standards
compatibility:
  unicode_standards:
    unicode_version: "Unicode 13.0 or later"
    normalization: "NFC normalization for text processing"
    bidi_support: "Bidirectional text support for international use"
  
  mathematical_notation:
    latex_compatibility: "Mapping to LaTeX mathematical notation"
    mathml_export: "Export capability to MathML format"
    presentation_markup: "Support for presentation vs content markup"
  
  programming_language_integration:
    c_cpp_export: "Generate C++ code with ASCII equivalents"
    python_interop: "Python integration with Unicode preservation"
    json_serialization: "JSON export with symbol metadata"

# Quality Assurance
quality_assurance:
  symbol_verification:
    unicode_validation: "Verify all Unicode symbols render correctly"
    ascii_equivalence: "Verify ASCII versions have same semantics"
    round_trip_testing: "Test Unicode → ASCII → Unicode conversion"
  
  usability_testing:
    keyboard_accessibility: "Test all symbols accessible via keyboard"
    discoverability: "Test symbol discoverability through completion"
    learning_curve: "Measure time to learn symbol input methods"
  
  performance_testing:
    transformation_speed: "Benchmark symbol transformation performance"
    memory_usage: "Measure memory overhead of symbol system"
    rendering_performance: "Test rendering performance with complex expressions"

# Configuration Options
configuration:
  user_preferences:
    default_mode: "unicode_preferred | ascii_preferred | mixed"
    auto_completion: "enabled | disabled | context_sensitive"
    symbol_rendering: "unicode | ascii | user_choice"
    keyboard_shortcuts: "configurable_key_bindings"
  
  project_settings:
    symbol_style: "Project-wide symbol style preferences"
    consistency_enforcement: "Enforce consistent symbol usage"
    export_formats: "Configure symbol handling for different export formats"
  
  accessibility_options:
    high_contrast: "High contrast symbol rendering"
    large_symbols: "Enlarged symbol display for accessibility"
    screen_reader: "Screen reader friendly symbol descriptions"
    keyboard_only: "Complete keyboard-only symbol input support"
